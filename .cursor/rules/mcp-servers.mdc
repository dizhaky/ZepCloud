---
description: MCP (Model Context Protocol) server development standards
alwaysApply: false
globs: ["**/mcp-servers/**/*"]
---

# MCP Server Development Standards

## Overview

MCP (Model Context Protocol) servers provide tools and context to AI assistants. This project includes:
- **TypingMind MCP**: Integration with TypingMind chat interface
- **ByteRover MCP**: Knowledge management and retrieval
- **Browser MCP**: Browser automation for testing

## MCP Health Check Protocol

**MANDATORY**: Every session MUST start with MCP server health checks:

### 1. ByteRover Knowledge Management
```typescript
// Test knowledge retrieval
mcp_byterover-mcp_byterover-retrieve-knowledge({ query: "health check", limit: 1 })

// Test knowledge storage
mcp_byterover-mcp_byterover-store-knowledge({ messages: "Session started - MCP health check" })
```

### 2. Git Operations
```typescript
mcp_git_git_status({ repo_path: "." })
```

### 3. Task Management
```typescript
mcp_task-master-ai_get_tasks({ projectRoot: "C:\\Dev\\ZepCloud" })
```

### 4. Browser Automation
```typescript
mcp_kapture_list_tabs({})
```

### 5. Memory System
```typescript
// Test memory operations if available
```

### 6. Filesystem Access
```typescript
list_dir({ target_directory: "." })
```

### 7. GitHub Integration
```typescript
// Test GitHub operations if token configured
```

### Health Check Results Format

Report results as:
```
## MCP Server Health Check Results

| Server | Status | Notes |
|--------|--------|-------|
| ByteRover | ✅ Working | Knowledge retrieval/storage functional |
| Git | ✅ Working | Repository operations available |
| Task Master | ✅ Working | Task management functional |
| Kapture | ✅ Working | Browser automation ready |
| Memory | ✅ Working | Session memory available |
| Filesystem | ✅ Working | File operations functional |
| GitHub | ⚠️ Needs Token | Configure GITHUB_PERSONAL_ACCESS_TOKEN |
```

### Error Handling

If any MCP server fails:
1. **Document the specific error message**
2. **Suggest troubleshooting steps**
3. **Continue with available servers**
4. **Note which functionality is unavailable**

## Server Structure

### Basic MCP Server Pattern

```typescript
// ✅ CORRECT - MCP server structure
import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
} from "@modelcontextprotocol/sdk/types.js";

class MyMCPServer {
  private server: Server;

  constructor() {
    this.server = new Server(
      {
        name: "my-mcp-server",
        version: "1.0.0",
      },
      {
        capabilities: {
          tools: {},
        },
      }
    );

    this.setupToolHandlers();
  }

  private setupToolHandlers() {
    // List available tools
    this.server.setRequestHandler(ListToolsRequestSchema, async () => ({
      tools: [
        {
          name: "my_tool",
          description: "Description of what this tool does",
          inputSchema: {
            type: "object",
            properties: {
              input: {
                type: "string",
                description: "Input parameter description",
              },
            },
            required: ["input"],
          },
        },
      ],
    }));

    // Handle tool calls
    this.server.setRequestHandler(CallToolRequestSchema, async (request) => {
      if (request.params.name === "my_tool") {
        const { input } = request.params.arguments as { input: string };
        
        try {
          const result = await this.processTool(input);
          return {
            content: [
              {
                type: "text",
                text: JSON.stringify(result, null, 2),
              },
            ],
          };
        } catch (error) {
          return {
            content: [
              {
                type: "text",
                text: `Error: ${error instanceof Error ? error.message : 'Unknown error'}`,
              },
            ],
            isError: true,
          };
        }
      }

      throw new Error(`Unknown tool: ${request.params.name}`);
    });
  }

  private async processTool(input: string): Promise<any> {
    // Tool implementation
    return { result: "processed" };
  }

  async start() {
    const transport = new StdioServerTransport();
    await this.server.connect(transport);
  }
}

// Start server
const server = new MyMCPServer();
server.start().catch(console.error);
```

## Tool Definition Best Practices

### Clear Input Schemas

```typescript
// ✅ CORRECT - Detailed input schema
{
  name: "search_documents",
  description: "Search documents using semantic search with filters",
  inputSchema: {
    type: "object",
    properties: {
      query: {
        type: "string",
        description: "Search query text (required)",
      },
      filters: {
        type: "object",
        description: "Optional filters for search results",
        properties: {
          date_from: {
            type: "string",
            format: "date",
            description: "Filter documents from this date (YYYY-MM-DD)",
          },
          date_to: {
            type: "string",
            format: "date",
            description: "Filter documents up to this date (YYYY-MM-DD)",
          },
          tags: {
            type: "array",
            items: { type: "string" },
            description: "Filter by tags",
          },
        },
      },
      limit: {
        type: "number",
        description: "Maximum number of results (default: 10, max: 100)",
        default: 10,
        minimum: 1,
        maximum: 100,
      },
    },
    required: ["query"],
  },
}
```

## Error Handling

### Comprehensive Error Responses

```typescript
// ✅ CORRECT - Detailed error handling
async function handleToolCall(request: CallToolRequest) {
  try {
    // Validate input
    const args = request.params.arguments as ToolArgs;
    if (!args.query || args.query.trim().length === 0) {
      return {
        content: [
          {
            type: "text",
            text: "Error: Query parameter is required and cannot be empty",
          },
        ],
        isError: true,
      };
    }

    // Execute tool
    const result = await executeSearch(args);
    
    return {
      content: [
        {
          type: "text",
          text: JSON.stringify(result, null, 2),
        },
      ],
    };
  } catch (error) {
    console.error("Tool execution failed:", error);
    
    return {
      content: [
        {
          type: "text",
          text: `Error: ${error instanceof Error ? error.message : 'Unknown error occurred'}`,
        },
      ],
      isError: true,
    };
  }
}
```

## Environment Configuration

### MCP Server Configuration

```json
// ✅ CORRECT - mcp.json configuration
{
  "mcpServers": {
    "typingmind-mcp": {
      "command": "node",
      "args": ["dist/index.js"],
      "env": {
        "ZEP_API_KEY": "${ZEP_API_KEY}",
        "RAILWAY_API_URL": "https://dans-knowledge-production.up.railway.app"
      }
    },
    "byterover-mcp": {
      "command": "npx",
      "args": ["-y", "@byterover/mcp-server"],
      "env": {
        "BYTEROVER_API_KEY": "${BYTEROVER_API_KEY}"
      }
    }
  }
}
```

## Testing MCP Servers

### Test Server Locally

```typescript
// ✅ CORRECT - Test script
import { Client } from "@modelcontextprotocol/sdk/client/index.js";
import { StdioClientTransport } from "@modelcontextprotocol/sdk/client/stdio.js";

async function testMCPServer() {
  const transport = new StdioClientTransport({
    command: "node",
    args: ["dist/index.js"],
  });

  const client = new Client(
    {
      name: "test-client",
      version: "1.0.0",
    },
    {
      capabilities: {},
    }
  );

  await client.connect(transport);

  // List available tools
  const tools = await client.listTools();
  console.log("Available tools:", tools);

  // Call a tool
  const result = await client.callTool({
    name: "my_tool",
    arguments: {
      input: "test input",
    },
  });
  
  console.log("Tool result:", result);

  await client.close();
}

testMCPServer().catch(console.error);
```

### Integration Testing

```bash
#!/bin/bash
# ✅ CORRECT - Test script for MCP server

echo "Testing MCP server..."

# Start server in background
node dist/index.js &
SERVER_PID=$!

# Wait for server to start
sleep 2

# Test tool execution
echo '{"method": "tools/list"}' | node dist/index.js

# Cleanup
kill $SERVER_PID

echo "Test complete"
```

## Deployment Patterns

### Railway Deployment

```json
// ✅ CORRECT - package.json for Railway deployment
{
  "name": "typingmind-mcp-server",
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "build": "tsc",
    "start": "node dist/index.js",
    "dev": "tsx src/index.ts"
  },
  "dependencies": {
    "@modelcontextprotocol/sdk": "^1.0.0",
    "zep-cloud": "^1.0.0"
  },
  "devDependencies": {
    "@types/node": "^20.0.0",
    "typescript": "^5.0.0",
    "tsx": "^4.0.0"
  }
}
```

### Railway Configuration

```json
// ✅ CORRECT - railway.json
{
  "$schema": "https://railway.app/railway.schema.json",
  "build": {
    "builder": "NIXPACKS"
  },
  "deploy": {
    "startCommand": "npm start",
    "restartPolicyType": "ON_FAILURE",
    "restartPolicyMaxRetries": 10
  }
}
```

## Logging and Monitoring

### Structured Logging

```typescript
// ✅ CORRECT - Structured logging for MCP servers
class Logger {
  info(message: string, data?: any) {
    console.error(
      JSON.stringify({
        level: "info",
        timestamp: new Date().toISOString(),
        message,
        ...data,
      })
    );
  }

  error(message: string, error?: any) {
    console.error(
      JSON.stringify({
        level: "error",
        timestamp: new Date().toISOString(),
        message,
        error: error instanceof Error ? error.message : error,
        stack: error instanceof Error ? error.stack : undefined,
      })
    );
  }
}

const logger = new Logger();

// Usage
logger.info("Tool executed", { tool: "search", duration: 150 });
logger.error("Tool failed", new Error("Connection timeout"));
```

## Performance Optimization

### Caching Strategies

```typescript
// ✅ CORRECT - Implement caching for expensive operations
import NodeCache from "node-cache";

const cache = new NodeCache({ stdTTL: 300 }); // 5 minutes

async function executeWithCache(key: string, fn: () => Promise<any>) {
  const cached = cache.get(key);
  if (cached) {
    logger.info("Cache hit", { key });
    return cached;
  }

  const result = await fn();
  cache.set(key, result);
  logger.info("Cache miss", { key });
  return result;
}

// Usage
const result = await executeWithCache(
  `search:${query}`,
  () => performSearch(query)
);
```

## Security Best Practices

### Input Validation

```typescript
// ✅ CORRECT - Validate all inputs
import { z } from "zod";

const SearchArgsSchema = z.object({
  query: z.string().min(1).max(500),
  limit: z.number().int().min(1).max(100).default(10),
  filters: z
    .object({
      date_from: z.string().regex(/^\d{4}-\d{2}-\d{2}$/).optional(),
      date_to: z.string().regex(/^\d{4}-\d{2}-\d{2}$/).optional(),
    })
    .optional(),
});

async function handleSearch(args: unknown) {
  try {
    const validated = SearchArgsSchema.parse(args);
    return await performSearch(validated);
  } catch (error) {
    if (error instanceof z.ZodError) {
      throw new Error(`Invalid input: ${error.errors[0].message}`);
    }
    throw error;
  }
}
```
